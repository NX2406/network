#!/bin/bash

# ==================================================
# 流量消耗/测速脚本 v13.1 (持久化修复版)
# ==================================================
# 更新日志：
# v13.1: 修复 curl 一键运行时的 screen 闪退问题 (自动下载到本地运行)

# 颜色配置
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# ==================================================
# 用户配置区
# ==================================================
# 10GB 文件源 (Hetzner)
DOWNLOAD_URL="https://fsn1-speed.hetzner.com/10GB.bin"

# 脚本自身下载地址 (用于 curl 模式下的自我修复)
# 如果你通过 curl 运行，请确保此地址指向的是【当前这个新脚本】的内容
SELF_URL="https://raw.githubusercontent.com/NX2406/network/main/Data%20usage"

# 本地保存路径
LOCAL_SCRIPT="/root/traffic_monitor.sh"

# ==================================================
# 核心功能区
# ==================================================

# 自动检测主网卡接口
INTERFACE=$(ip route get 8.8.8.8 | awk 'NR==1 {print $5}')

# 记录初始字节数 (优先 sysfs，失败则用 /proc/net/dev)
START_RX=$(cat /sys/class/net/$INTERFACE/statistics/rx_bytes 2>/dev/null)
START_TX=$(cat /sys/class/net/$INTERFACE/statistics/tx_bytes 2>/dev/null)
if [ -z "$START_RX" ]; then
    START_RX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $2}')
    START_TX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $10}')
fi

START_TIME=$(date +%s)

# 捕获 Ctrl+C
trap 'cleanup' INT

# 流量转换函数 (Bytes -> GB)
to_gb() {
    local bytes=$1
    awk "BEGIN {printf \"%.2f\", $bytes/1024/1024/1024}"
}

cleanup() {
    echo -e "\n${RED}[!] 正在停止所有任务...${NC}"
    kill $(jobs -p) 2>/dev/null
    
    # 再次读取网卡数据
    END_TIME=$(date +%s)
    END_RX=$(cat /sys/class/net/$INTERFACE/statistics/rx_bytes 2>/dev/null)
    END_TX=$(cat /sys/class/net/$INTERFACE/statistics/tx_bytes 2>/dev/null)
    if [ -z "$END_RX" ]; then
        END_RX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $2}')
        END_TX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $10}')
    fi

    # 计算差值
    RX_DIFF=$((END_RX - START_RX))
    TX_DIFF=$((END_TX - START_TX))
    TOTAL_BYTES=$((RX_DIFF + TX_DIFF))
    
    TOTAL_GB=$(to_gb $TOTAL_BYTES)
    DURATION=$((END_TIME - START_TIME))
    
    # 计算平均速度 (MB/s)
    if [ $DURATION -gt 0 ]; then
        AVG_SPEED=$(awk "BEGIN {printf \"%.2f\", ($TOTAL_BYTES/1024/1024)/$DURATION}")
    else
        AVG_SPEED="0"
    fi

    echo -e "${GREEN}==========================================${NC}"
    echo -e "   🏁 运行结束"
    echo -e "   ⏱️  总运行时长: ${YELLOW}${DURATION} 秒${NC}"
    echo -e "   📉 监测网卡:    ${PURPLE}${INTERFACE}${NC}"
    echo -e "   📊 实际消耗流量: ${CYAN}${TOTAL_GB} GB${NC} (真实统计)"
    echo -e "   🚀 平均流量速度: ${CYAN}${AVG_SPEED} MB/s${NC}"
    echo -e "${GREEN}==========================================${NC}"
    exit 0
}

# 1. 依赖检查
check_dep() {
    # 检查 wget
    if ! command -v wget &> /dev/null; then 
        echo -e "${YELLOW}[*] 安装 wget...${NC}"
        apt-get install -y wget || yum install -y wget
    fi
    # 检查 screen
    if ! command -v screen &> /dev/null; then
        echo -e "${YELLOW}[*] 安装 screen...${NC}"
        if [ -f /etc/redhat-release ]; then
            yum install -y screen
        else
            apt-get install -y screen
        fi
    fi
}

# 2. 暴力修复 DNS
fix_dns() {
    echo -e "${YELLOW}[*] 正在优化网络配置...${NC}"
    echo "nameserver 8.8.8.8" > /etc/resolv.conf
    echo "nameserver 1.1.1.1" >> /etc/resolv.conf
}

# 3. 仪表盘
show_dashboard() {
    clear
    NOW_TIME=$(date +%s)
    RUN_TIME=$((NOW_TIME - START_TIME))
    
    # 实时计算当前消耗
    CUR_RX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $2}')
    CUR_TX=$(grep "$INTERFACE" /proc/net/dev | awk '{print $10}')
    CUR_TOTAL=$(( (CUR_RX - START_RX) + (CUR_TX - START_TX) ))
    CUR_GB=$(to_gb $CUR_TOTAL)

    echo -e "${BLUE}#################################################${NC}"
    echo -e "${BLUE}#        流量消耗挂机脚本 v13.1 (稳定版)        #${NC}"
    echo -e "${BLUE}#################################################${NC}"
    echo -e ""
    echo -e "   🚀 ${GREEN}目标文件:${NC} Hetzner 10GB (无限循环)"
    echo -e "   ⚡ ${GREEN}并发进程:${NC} ${CYAN}${CURRENT_THREADS}${NC}"
    echo -e "   ⏱️  ${GREEN}运行时间:${NC} ${YELLOW}${RUN_TIME} 秒${NC}"
    echo -e "   📊 ${GREEN}实时流量:${NC} ${RED}${CUR_GB} GB${NC} (统计中...)"
    echo -e ""
    echo -e "${BLUE}-------------------------------------------------${NC}"
    echo -e "${PURPLE}正在全速下载中 (主线程进度):${NC}"
}

# 4. 运行逻辑
run_traffic() {
    local threads=$1
    CURRENT_THREADS=$threads
    
    show_dashboard

    while true; do
        # 启动 N-1 个后台静默进程
        for ((i=1; i<threads; i++)); do
            wget -O /dev/null -q --timeout=10 --tries=2 "$DOWNLOAD_URL" &
        done
        
        # 启动 1 个前台进程 (显示进度条)
        wget -O /dev/null --progress=bar:force "$DOWNLOAD_URL"
        
        # 等待本轮结束
        wait
        
        # 刷新仪表盘
        show_dashboard
        echo -e "${GREEN} >> 完成一轮循环，立即重置...${NC}"
        sleep 1
    done
}

# 5. 主菜单 (流量逻辑入口)
main_menu() {
    clear
    echo -e "================================================="
    echo -e "    流量消耗脚本 v13.1 (持久化稳定版)"
    echo -e "================================================="
    echo -e "1. ${GREEN}默认模式${NC} (10 线程)"
    echo -e "2. ${GREEN}自定义模式${NC} (手动输入线程数)"
    echo -e "0. 退出"
    echo -e "================================================="
    read -p "请选择: " choice

    case $choice in
        1) run_traffic 10 ;;
        2) 
            read -p "请输入线程数 (推荐 20-50): " t
            if [[ ! "$t" =~ ^[0-9]+$ ]]; then t=10; fi
            run_traffic $t 
            ;;
        *) exit 0 ;;
    esac
}

# ==================================================
# 6. 智能持久化启动 (修复闪退问题的核心)
# ==================================================
start_logic() {
    if [[ $EUID -ne 0 ]]; then echo -e "${RED}必须 root 运行${NC}"; exit 1; fi
    check_dep
    fix_dns

    # 情况 A: 已经在 Screen 会话中 -> 直接运行业务逻辑
    if [ ! -z "$STY" ]; then
        main_menu
        exit 0
    fi

    # 情况 B: 外部环境
    SESSION_NAME="traffic_monitor"

    # 检查是否有已经在运行的会话
    if screen -list | grep -q "$SESSION_NAME"; then
        echo -e "${GREEN}[+] 检测到后台已有运行中的任务！${NC}"
        echo -e "正在重新连接..."
        sleep 2
        screen -r "$SESSION_NAME"
        exit 0
    fi

    # 询问用户是否开启后台模式
    clear
    echo -e "================================================="
    echo -e "    ${YELLOW}🛡️  防断连持久化模式设置 🛡️${NC}"
    echo -e "================================================="
    echo -e "SSH 断开后，脚本是否需要继续运行？"
    echo -e "  [y] 是 (推荐，自动进入 Screen 后台环境)"
    echo -e "  [n] 否 (普通模式，SSH断开则停止)"
    echo -e ""
    read -p "请选择 [y/n] (默认 y): " use_screen
    use_screen=${use_screen:-y}

    if [[ "$use_screen" == "y" ]]; then
        # === 核心修复: 检测脚本是否存在于本地 ===
        # 如果 $0 不是真实文件 (比如 bash 管道运行)，则 screen 无法启动
        if [[ ! -f "$0" ]] || [[ "$0" == "bash" ]]; then
            echo -e "${RED}[!] 检测到 Curl 内存运行模式，正在下载脚本到本地...${NC}"
            
            # 尝试下载自身
            wget -O "$LOCAL_SCRIPT" "$SELF_URL"
            
            if [[ -f "$LOCAL_SCRIPT" ]]; then
                chmod +x "$LOCAL_SCRIPT"
                echo -e "${GREEN}[+] 下载成功！正在切换到本地文件模式...${NC}"
                sleep 1
                # 重新执行本地文件，带参数以跳过询问? 
                # 这里简单处理：重新执行本地文件，用户只需再按一次 y
                exec "$LOCAL_SCRIPT"
            else
                echo -e "${RED}[Error] 下载脚本失败，请检查网络或手动下载！${NC}"
                exit 1
            fi
        fi

        # 此时 $0 已经是本地文件路径了
        echo -e "${YELLOW}[*] 正在创建后台会话 '$SESSION_NAME'...${NC}"
        echo -e "${PURPLE}[提示] 按 Ctrl+A 然后按 D 可挂起离开，任务不会停止。${NC}"
        sleep 2
        
        # 启动 screen 并运行当前脚本
        screen -U -S "$SESSION_NAME" /bin/bash "$0"
    else
        # 普通模式
        main_menu
    fi
}

# 脚本入口
start_logic
